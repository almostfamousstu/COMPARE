**Objective:** Build a complete, production-ready, full-stack web application using Next.js, TypeScript, and Tailwind CSS. The app must allow a user to compare a custom list of key-value pairs against a list of key-value pairs generated by the Google Gemini LLM for a given SKU, with a sleek, modern, and highly interactive UI.

### 1. Project Stack & Setup

*   **Framework:** **Next.js 14** (App Router, Server Components where possible).
*   **Language:** **TypeScript** end-to-end.
*   **Styling:** **Tailwind CSS** for a utility-first, modern design.
*   **UI Components:** Use **shadcn/ui** components for all UI elements (Button, Input, Card, Table, Switch, etc.) to ensure a sleek, accessible, and theme-aware design (including built-in Dark Mode).
*   **Backend:** Next.js API Routes (Serverless Functions) to proxy the LLM call.
*   **LLM SDK:** **`@google/generative-ai`** package.

### 2. Frontend (UI/UX) Requirements: Sleek, Modern, Interactive

The design must follow a **minimalist, high-contrast aesthetic** with a default **Dark Mode** preference.

#### A. Input Component (Client Component)
1.  **Layout:** A single-page application structure with a central `Card` or `Form` component.
2.  **User-Provided Data Input:**
    *   A simple `Input` field for the user to provide the **SKU** (e.g., "SKU-90210").
    *   A single, large, multi-line `Textarea` for the user to paste their **Key-Value Pairs** data. Instruct the user to format this as a JSON object of type `Record<string, string>` or a plain list that the application will parse/validate.
3.  **Action:** A primary `Button` labeled **"Compare SKU"**. This button must have a **subtle hover animation** and be disabled while a comparison is running.

#### B. Comparison Visualization (Client Component)
This is the core UI feature. It must be highly scannable and visually distinct.
1.  **Structure:** A full-width, responsive, **three-column comparison table** with fixed headers: **"Attribute"**, **"Your Value"**, and **"LLM Value"**.
2.  **Visual Queues (Diff Highlighting):** Implement a precise diff visualization:
    *   The entire table row should be rendered normally if `Your Value` === `LLM Value`.
    *   If `Your Value` !== `LLM Value`, the **`LLM Value` cell** must be highlighted with a clear, subtle **color-coded background** (e.g., a soft, contrasting color like light orange/red in Dark Mode) to immediately flag the mismatch.
3.  **Interactivity/Bells & Whistles:**
    *   **"Show Only Differences" Toggle:** A `Switch` component above the table allowing the user to filter the results to show **only** the rows where `Your Value` is different from `LLM Value`.
    *   **Hover Effects:** Implement a subtle background change on row hover to improve readability and focus.
    *   **Loading State:** Display a modern, center-aligned **skeletal loader** or a pulsing animation in the table area while waiting for the Gemini API response.

### 3. Backend (API/LLM) Requirements: Structured Output

Create a Next.js API Route at `/api/compare`.

1.  **Request Handling:** Accept a `POST` request containing the user's SKU and the parsed user-provided key-value JSON object (`userKVPairs: Record<string, string>`).
2.  **Gemini Call Logic:**
    *   Initialize the Gemini client using the `GEMINI_API_KEY` environment variable.
    *   Use the **`gemini-2.5-flash`** model.
    *   **Enforce JSON Output:** Utilize the Gemini API's native structured output feature by setting **`responseMimeType: "application/json"`** in the `generationConfig`.
    *   **Define `responseSchema`:** Construct a JSON Schema that strictly defines the LLM's expected output as an object where the keys match the keys provided by the user (from `userKVPairs`) and all values are of type `string`.
    *   **Pre-configured System Prompt:** The system prompt must instruct the LLM to act as a **"SKU Specification Generator"** and *only* populate the JSON object according to the provided schema, using the SKU as context and the user's keys as required fields.
3.  **Response:** The API should return the LLM's generated JSON object (`llmKVPairs: Record<string, string>`) to the frontend.

### 4. Core Comparison Logic

The frontend must implement a utility function to merge and compare the two key-value objects (`userKVPairs` and `llmKVPairs`) into a single array structure suitable for the comparison table.

**Data Structure for UI State:**
```typescript
interface ComparisonResult {
  attribute: string;
  userValue: string;
  llmValue: string;
  isMismatch: boolean; // True if userValue !== llmValue
}

// Result Array Example:
const comparisonData: ComparisonResult[] = [
  { attribute: 'Color', userValue: 'Red', llmValue: 'Red', isMismatch: false },
  { attribute: 'Material', userValue: 'Wood', llmValue: 'Plastic', isMismatch: true },
  // ...
];
```

**Task:** Generate all necessary files (including `package.json`, `.env.local.example`, a default `layout.tsx`, the primary page component, the API route, and any necessary UI components) to deliver the full application. **Focus on clean, modern, and reusable component-based code.**
